# MIPS32 Pipeline (with 2‑way Instruction Cache)

Self‑checking Verilog testbenches and scripts for a simple MIPS32 pipeline core and an optional 2‑way set‑associative instruction cache. The repository is designed so anyone with Icarus Verilog can build, run, and reproduce the results in a few commands.

---

## Requirements
- **Icarus Verilog** (`iverilog`, `vvp`)
- **bash** (macOS/Linux; Windows via WSL is fine)
- **GTKWave** (optional, for viewing VCD waveforms)

---

## Repository Layout
```
.
├── mips32_pipeline.v               # CPU pipeline (supports imem_ready for IF stall)
├── icache_2way.v                   # 2‑way set‑associative I‑cache
├── tb_mips32_pipeline_strict.v     # Strict, self‑checking TB (no cache)
├── tb_mips32_pipeline_icache.v     # CPU + I‑cache integration TB
├── fib32_pipeline.v                # Simple TB (fib: store 13 to 0xFC)
├── sum32_pipeline.v                # Simple TB (sum 0..20 = 210 to 0xFC)
├── make_hex.sh                     # Generates positive test HEX files
├── make_negative_hex.sh            # Generates negative test HEX files
└── run_all.sh                      # Runs the full positive + negative suites
```

---

## Quick Start
```bash
# 1) Generate HEX vectors (positive + negative tests)
./make_hex.sh
./make_negative_hex.sh

# 2) Run all tests with the strict testbench
./run_all.sh
```
The script prints a table of **PASS/FAIL** with basic performance stats and returns a useful exit code:
- `0`  → all tests passed (including negative tests behaving as expected)
- `1`  → some tests failed or a negative test unexpectedly passed

> The script auto‑detects the number of words in each HEX file and passes `+WORDS=<N>` to the simulator to silence `$readmemh` range warnings.

---

## Plusargs Used in Testbenches
- `+HEX=<file>`: instruction memory initialization file (e.g., `alu_basic.dat`).
- `+WORDS=<N>`: limit `$readmemh` to the first N words of the HEX file (avoids warnings when files are short).
- `+FINISH_ADDR=<dec>` / `+FINISH_DATA=<dec>`: override success condition in strict TBs (defaults: `252` and `13`).

---

## Individual Testbenches

### 1) Strict self‑checking TB (no cache)
```bash
iverilog -g2012 -o tb_strict.out tb_mips32_pipeline_strict.v mips32_pipeline.v
vvp tb_strict.out +HEX=alu_basic.dat +WORDS=5
```
This bench:
- Monitors data‑memory stores to detect success (default: store `13` to address `252`).
- Checks simple invariants (e.g., forbids writes to `$zero`, no store when EX/MEM is invalid).
- Prints performance counters: cycles, retired instructions, branch prediction stats.

### 2) Fibonacci TB
```bash
iverilog -g2012 -o fib_tb.out fib32_pipeline.v mips32_pipeline.v
vvp fib_tb.out +HEX=fib32.dat +WORDS=3
```
Stores `13` to `0xFC` and loops. Good for smoke testing.

### 3) Sum TB
```bash
iverilog -g2012 -DHAS_PERF_COUNTERS -o sum_tb.out sum32_pipeline.v mips32_pipeline.v
vvp sum_tb.out +HEX=sum32.dat +WORDS=7
```
Sums `0..20` and stores `210` to `0xFC`.

### 4) CPU + 2‑way I‑cache integration TB
```bash
iverilog -g2012 -o tb_icache.out tb_mips32_pipeline_icache.v icache_2way.v mips32_pipeline.v
vvp tb_icache.out +HEX=fib32.dat +WORDS=3
```
Notes:
- The pipeline feeds the I‑cache and **stalls the IF stage** via `imem_ready` on cache misses (no clock gating in the DUT).
- The testbench reports I‑cache statistics (`hits`, `misses`, `stall_cycles`).

---

## Positive Tests (generated by `make_hex.sh`)
A curated set of short programs covering ALU ops, hazards, mult/div with HI/LO, branches (taken/NT, predictor stress), memory round‑trips, shifts, SLT, and store‑flush protections. Examples include:
- `alu_basic.dat`, `hazard_forward.dat`, `load_use_stall.dat`, `muldiv_hi_lo.dat`, `div_hi_add.dat`,
- `branch_mix.dat`, `branch_mispredict_stress.dat`, `mem_sw_lw_use.dat`, `slt_signed.dat`, `sra_sign_arith.dat`,
- `flush_store_guard_taken.dat`, plus convenience programs `fib32.dat` and `sum32.dat`.

## Negative Tests (generated by `make_negative_hex.sh`)
These are **expected to trip errors** in the strict TB:
- Misaligned store/load
- IMEM out‑of‑range fetch
- DMEM out‑of‑range store/load

`run_all.sh` marks them as **EXPECTED‑FAIL** when the TB prints `ERROR:` and fails the suite if any of them unexpectedly pass.

---

## Waveforms
All benches write a VCD file that you can inspect with GTKWave:
```bash
gtkwave dump_pipeline.vcd &          # strict / fib
# or
gtkwave dump_pipeline_pr.vcd &       # sum
# or
gtkwave dump_pipeline_icache.vcd &   # icache integration
```

---

## CPU Pipeline Architecture

The core is a classic 5‑stage in‑order pipeline:

1. **IF – Instruction Fetch**  
   - Port: `imem_addr` (output), `imem_data` (input), **`imem_ready` (input)**.  
   - The PC and the IF/ID register advance **only when `imem_ready=1`**. In testbenches without a cache this is tied high; with the I‑cache it stalls on misses.
2. **ID – Decode / Register Read**  
   - Decodes opcode/funct, reads register file, generates control.  
   - Handles J/JR/JAL and conditional branches (flush logic on control transfer).
3. **EX – Execute / Address Gen**  
   - ALU ops, branch compare/target, mult/div kick‑off, effective address calc.
4. **MEM – Data Memory**  
   - Synchronous store (TB RAM writes on `posedge clk`), asynchronous read in TB model.  
   - Store side‑effects are used by TBs to assert success or errors.
5. **WB – Write Back**  
   - Writes results to the register file (except `$zero`). TB enforces *“no writeback to `$zero`”*.

### Hazard Handling
- **Data forwarding**: EX/MEM and MEM/WB bypass paths cover ALU‑to‑ALU and mixed sequences (see `hazard_forward.dat`).
- **Load‑use interlock**: one‑cycle stall when an instruction consumes a just‑loaded value (see `load_use_stall.dat`).
- **Control hazards**: early resolution for taken branches and proper pipeline flush so that fall‑through side‑effects are suppressed (see `branch_mix.dat`, `flush_store_guard_taken.dat`).
- **MULT/DIV & HI/LO**: verified with MFLO/MFHI sequences (`muldiv_hi_lo.dat`, `div_hi_add.dat`). The core may stall as needed to ensure correctness.

### Memory Interfaces (TB models)
- **IMEM**: simple ROM initialized via `$readmemh`. In the strict TB it is zero‑wait; in the I‑cache TB it feeds the cache.  
  Use `+HEX=<file>` and optional `+WORDS=<N>` (limits `$readmemh` to first N words) to silence range warnings.
- **DMEM**: synchronous write / asynchronous read RAM used by the TBs to check architectural state (e.g., success at address `0xFC`).

### Performance Counters
- `cycle_count` – increments every cycle.  
- `inst_count` – intended to count **retired** (committed) instructions at WB. If tied to `regwrite`, branches/stores will not be counted; the README’s numbers assume a WB‑commit style counter.  
- `branch_predict_correct`, `branch_predict_total` – implementation‑defined predictor hooks; the TBs just report the values.

### Pipeline Overview Diagram
```
IF ──► ID ──► EX ──► MEM ──► WB
│       │       │       │
│       │       │       └─ sync store / async read (TB model)
│       │       └────────── ALU/compare/addr gen, branch target
│       └──────────────────── decode, regfile read, control
└──────────────────────────── PC update & fetch (gated by imem_ready)
```

### Performance Notes (where the cycles go)
- **Ideal CPI** on straight‑line ALU code with zero‑wait memories ≈ **1.0** (after pipeline fill).
- **Load‑use hazard**: +1 cycle bubble when the consumer immediately follows a load.
- **Taken branch**: pipeline flush cost depends on early/late resolution; the provided tests model early resolution (see `branch_mix.dat`).
- **I‑cache miss**: IF stage stalls until the cache line is filled; hits run at 1 inst/cycle.
- **Tiny programs** (few instructions) show inflated CPI due to fill/flush effects. Use longer HEX sequences for stable CPI.

---

## Instruction Cache Integration (2‑way set‑associative)
- File: `icache_2way.v`. Exposes a CPU‑side handshake: `cpu_addr`, `cpu_req`, `cpu_data`, `cpu_ready`, `cpu_stall`.
- The pipeline’s **`imem_ready`** input connects to the cache’s `cpu_ready`. On misses the IF stage naturally stalls; on hits it runs at 1 inst/cycle (subject to other hazards).
- The cache talks to the TB’s backing IMEM via `mem_addr/mem_req/mem_data/mem_ready`. The provided TB config models a single‑cycle per word line fill.
- Integration bench: `tb_mips32_pipeline_icache.v` prints cache stats (`hits/misses/stall_cycles`).

**Build & run:**
```bash
iverilog -g2012 -o tb_icache.out tb_mips32_pipeline_icache.v icache_2way.v mips32_pipeline.v
vvp tb_icache.out +HEX=fib32.dat +WORDS=3
```

---

## Example Measurements (illustrative)
These are representative numbers from the provided benches; your results may vary by tool/version:

- **Strict TB – Branch predictor stress** (`branch_mispredict_stress.dat`):  
  cycles ≈ **15**, retired ≈ **9**, predictor **1 / 3** → CPI ≈ **1.67**.
- **Sum TB** (`sum32.dat`, with `-DHAS_PERF_COUNTERS`):  
  cycles = **128**, retired = **83**, predictor **19 / 21** → CPI ≈ **1.54**.
- **I‑cache integration – Fibonacci** (`fib32.dat`):  
  cycles = **7**, retired = **3**, cache **hits=4**, **misses=1**, **stall_cycles=0** → initial CPI ≈ **2.33** for this tiny program; steady state after fill is 1 inst/cycle on hits.

---

## Configuration Summary
- **Parameters**: `WIDTH=32`, `REGBITS=5` (CPU).  
- **IMEM ports**: `imem_addr[WIDTH-1:0]`, `imem_data[WIDTH-1:0]`, `imem_ready`.  
- **DMEM ports**: `dmem_addr[WIDTH-1:0]`, `dmem_wdata[WIDTH-1:0]`, `dmem_we`, `dmem_rdata[WIDTH-1:0]`.  
- **Counters**: `cycle_count`, `inst_count`, `branch_predict_correct`, `branch_predict_total`.

---

## License

MIT License

Copyright (c) 2025 teruyo14

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
